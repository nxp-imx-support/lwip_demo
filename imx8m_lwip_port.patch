diff --git a/port/arch/cc.h b/port/arch/cc.h
new file mode 100644
index 00000000..542fc36f
--- /dev/null
+++ b/port/arch/cc.h
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ * Author: Stefano Oliveri <stefano.oliveri@st.com>
+ *
+ */
+
+/*
+ * Copyright 2022-2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __CC_H__
+#define __CC_H__
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#define LWIP_TIMEVAL_PRIVATE  0
+#include <sys/time.h>
+
+/* Typedefs for the types used by lwip */
+typedef uint8_t		u8_t;
+typedef uint16_t	u16_t;
+typedef uint32_t	u32_t;
+typedef int8_t		s8_t;
+typedef int16_t	  s16_t;
+typedef int32_t   s32_t;
+
+typedef uintptr_t       mem_ptr_t;
+
+/* Compiler hints for packing LWIP's structures */
+#define PACK_STRUCT_BEGIN
+#define PACK_STRUCT_STRUCT __attribute__((packed, aligned(1)))
+#define PACK_STRUCT_END
+#define PACK_STRUCT_FIELD(x) x
+
+/* Plaform specific diagnostic output */
+// non-fatal, print a message.
+#define LWIP_PLATFORM_DIAG(x)   do {printf x; printf("\r\n");} while(0)
+
+// fatal, print message and abandon execution.
+#define LWIP_PLATFORM_ASSERT(x) do {printf("Assertion \"%s\" failed at line %d in %s\n", \
+                                     x, __LINE__, __FILE__) ; abort();} while(0)
+
+#endif /* __CC_H__ */
diff --git a/port/arch/sys_arch.h b/port/arch/sys_arch.h
new file mode 100644
index 00000000..1780b851
--- /dev/null
+++ b/port/arch/sys_arch.h
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+/*
+ * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
+ * Copyright 2016-2017,2020,2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __ARCH_SYS_ARCH_H__
+#define __ARCH_SYS_ARCH_H__
+
+#include "lwip/opt.h"
+#include "arch/cc.h"
+#include "cmsis_gcc.h"
+
+#if !NO_SYS
+
+#include "FreeRTOS.h"
+#include "task.h"
+#include "queue.h"
+#include "semphr.h"
+
+#endif
+
+#define SYS_MBOX_NULL					( ( QueueHandle_t ) NULL )
+#define SYS_SEM_NULL					( ( SemaphoreHandle_t ) NULL )
+#define SYS_DEFAULT_THREAD_STACK_DEPTH	configMINIMAL_STACK_SIZE
+#if !NO_SYS
+typedef SemaphoreHandle_t sys_sem_t;
+typedef SemaphoreHandle_t sys_mutex_t;
+typedef QueueHandle_t sys_mbox_t;
+typedef TaskHandle_t sys_thread_t;
+
+#define sys_mbox_valid( x ) ( ( ( *x ) == NULL) ? pdFALSE : pdTRUE )
+#define sys_mbox_set_invalid( x ) ( ( *x ) = NULL )
+#define sys_sem_valid( x ) ( ( ( *x ) == NULL) ? pdFALSE : pdTRUE )
+#define sys_sem_set_invalid( x ) ( ( *x ) = NULL )
+
+#else /* NO_SYS */ /* Bare-metal */
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+void time_isr(void);
+void time_init(void);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif
+
+typedef unsigned long sys_prot_t;
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+void sys_assert( char *msg );
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif /* __ARCH_SYS_ARCH_H__ */
diff --git a/port/enet_ethernetif.c b/port/enet_ethernetif.c
new file mode 100644
index 00000000..4b5e40ee
--- /dev/null
+++ b/port/enet_ethernetif.c
@@ -0,0 +1,305 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+/*
+ * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
+ * Copyright 2016-2020, 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+#include "lwip/mem.h"
+#include "lwip/pbuf.h"
+#include "lwip/stats.h"
+#include "lwip/snmp.h"
+#include "lwip/ethip6.h"
+#include "netif/etharp.h"
+#include "netif/ppp/pppoe.h"
+#include "lwip/igmp.h"
+#include "lwip/mld6.h"
+
+#if USE_RTOS && defined(SDK_OS_FREE_RTOS)
+#include "FreeRTOS.h"
+#include "event_groups.h"
+#endif
+
+#include "enet_ethernetif.h"
+#include "enet_ethernetif_priv.h"
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+
+/*******************************************************************************
+ * Code
+ ******************************************************************************/
+
+int _write(int handle, char *buffer, int size)
+{
+        if (NULL == buffer)
+        {
+                /* return -1 if error. */
+                return -1;
+        }
+
+        /* This function only writes to "standard out" and "standard err" for all other file handles it returns failure. */
+        if ((handle != 1) && (handle != 2))
+        {
+                return -1;
+        }
+
+        int i;
+        for(i = 0; i < size; i++) {
+                if (buffer[i] == '\n') {
+                        DbgConsole_Putchar('\r');
+                }
+                DbgConsole_Putchar(buffer[i]);
+        }
+
+        return size;
+}
+
+void ethernetif_phy_init(struct ethernetif *ethernetif,
+                         const ethernetif_config_t *ethernetifConfig,
+                         phy_speed_t *speed,
+                         phy_duplex_t *duplex)
+{
+    status_t status;
+    bool link              = false;
+    bool autonego          = false;
+    uint32_t initWaitCount = 0;
+    uint32_t autoWaitCount = 0;
+    phy_config_t phyConfig = {
+        .phyAddr = ethernetifConfig->phyHandle->phyAddr,
+        .autoNeg = true,
+    };
+
+    ethernetifConfig->phyHandle->mdioHandle->resource.base = *ethernetif_enet_ptr(ethernetif);
+
+    LWIP_PLATFORM_DIAG(("Initializing PHY...\n"));
+
+    while ((initWaitCount < ENET_ATONEGOTIATION_TIMEOUT) && (!(link && autonego)))
+    {
+        status = PHY_Init(ethernetifConfig->phyHandle, &phyConfig);
+
+        if (kStatus_Success != status)
+        {
+            LWIP_ASSERT("\r\nCannot initialize PHY.\r\n", 0);
+        }
+
+        /* Wait for auto-negotiation success and link up */
+        autoWaitCount = ENET_ATONEGOTIATION_TIMEOUT;
+        do
+        {
+            PHY_GetAutoNegotiationStatus(ethernetifConfig->phyHandle, &autonego);
+            PHY_GetLinkStatus(ethernetifConfig->phyHandle, &link);
+            if (autonego && link)
+            {
+                break;
+            }
+        } while (--autoWaitCount);
+        if (!autonego)
+        {
+            PRINTF("PHY Auto-negotiation failed. Please check the cable connection and link partner setting.\r\n");
+        }
+
+        initWaitCount++;
+    }
+
+    if (autonego && link)
+    {
+        /* Get the actual PHY link speed. */
+        PHY_GetLinkSpeedDuplex(ethernetifConfig->phyHandle, speed, duplex);
+        LWIP_PLATFORM_DIAG(("PHY initialization succeeded\n"));
+    }
+#if 0 /* Disable assert. If initial auto-negation is timeout, \ \
+         the ENET is set to default (100Mbs and full-duplex). */
+    else
+    {
+        LWIP_ASSERT("\r\nGiving up PHY initialization. Please check the ENET cable connection and link partner setting and reset the board.\r\n", 0);
+    }
+#endif
+}
+
+/**
+ * This function should be called when a packet is ready to be read
+ * from the interface. It uses the function ethernetif_linkinput() that
+ * should handle the actual reception of bytes from the network
+ * interface. Then the type of the received packet is determined and
+ * the appropriate input function is called.
+ *
+ * @param netif the lwip network interface structure for this ethernetif
+ */
+void ethernetif_input(struct netif *netif)
+{
+    struct pbuf *p;
+
+    LWIP_ASSERT("netif != NULL", (netif != NULL));
+    /* move received packet into a new pbuf */
+    while ((p = ethernetif_linkinput(netif)) != NULL)
+    {
+        /* pass all packets to ethernet_input, which decides what packets it supports */
+        if (netif->input(p, netif) != ERR_OK)
+        {
+            LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_input: IP input error\n"));
+            pbuf_free(p);
+            p = NULL;
+        }
+    }
+}
+
+void *ethernetif_get_enet_base(const uint8_t enetIdx)
+{
+    ENET_Type *enets[] = ENET_BASE_PTRS;
+    int arrayIdx;
+    int enetCount;
+
+    for (arrayIdx = 0, enetCount = 0; arrayIdx < ARRAY_SIZE(enets); arrayIdx++)
+    {
+        if (enets[arrayIdx] != 0U) /* process only defined positions */
+        {                          /* (some SOC headers count ENETs from 1 instead of 0) */
+            if (enetCount == enetIdx)
+            {
+                return (void *)enets[arrayIdx];
+            }
+            enetCount++;
+        }
+    }
+
+    return NULL;
+}
+
+#if defined(FSL_FEATURE_SOC_ENET_QOS_COUNT) && (FSL_FEATURE_SOC_ENET_QOS_COUNT > 0)
+void *ethernetif_get_enet_qos_base(const uint8_t enetIdx)
+{
+    ENET_QOS_Type *enets[] = ENET_QOS_BASE_PTRS;
+    int arrayIdx;
+    int enetCount;
+
+    for (arrayIdx = 0, enetCount = 0; arrayIdx < ARRAY_SIZE(enets); arrayIdx++)
+    {
+        if (enets[arrayIdx] != 0U) /* process only defined positions */
+        {                          /* (some SOC headers count ENETs from 1 instead of 0) */
+            if (enetCount == enetIdx)
+            {
+                return (void *)enets[arrayIdx];
+            }
+            enetCount++;
+        }
+    }
+
+    return NULL;
+}
+#endif
+
+err_t ethernetif_init(struct netif *netif,
+                      struct ethernetif *ethernetif,
+                      void *enetBase,
+                      const ethernetif_config_t *ethernetifConfig)
+{
+    LWIP_ASSERT("netif != NULL", (netif != NULL));
+    LWIP_ASSERT("ethernetifConfig != NULL", (ethernetifConfig != NULL));
+
+#if LWIP_NETIF_HOSTNAME
+    /* Initialize interface hostname */
+    netif->hostname = "rt-labs-dev";
+#endif /* LWIP_NETIF_HOSTNAME */
+
+    /*
+     * Initialize the snmp variables and counters inside the struct netif.
+     * The last argument should be replaced with your link speed, in units
+     * of bits per second.
+     */
+    MIB2_INIT_NETIF(netif, snmp_ifType_ethernet_csmacd, 100);
+
+    netif->state   = ethernetif;
+    netif->name[0] = IFNAME0;
+    netif->name[1] = IFNAME1;
+/* We directly use etharp_output() here to save a function call.
+ * You can instead declare your own function an call etharp_output()
+ * from it if you have to do some checks before sending (e.g. if link
+ * is available...) */
+#if LWIP_IPV4
+    netif->output = etharp_output;
+#endif
+#if LWIP_IPV6
+    netif->output_ip6 = ethip6_output;
+#endif /* LWIP_IPV6 */
+    netif->linkoutput = ethernetif_linkoutput;
+
+#if LWIP_IPV4 && LWIP_IGMP
+    netif_set_igmp_mac_filter(netif, ethernetif_igmp_mac_filter);
+    netif->flags |= NETIF_FLAG_IGMP;
+#endif
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+    netif_set_mld_mac_filter(netif, ethernetif_mld_mac_filter);
+    netif->flags |= NETIF_FLAG_MLD6;
+#endif
+
+    /* Init ethernetif parameters.*/
+    *ethernetif_enet_ptr(ethernetif) = enetBase;
+    LWIP_ASSERT("*ethernetif_enet_ptr(ethernetif) != NULL", (*ethernetif_enet_ptr(ethernetif) != NULL));
+
+    /* set MAC hardware address length */
+    netif->hwaddr_len = ETH_HWADDR_LEN;
+
+    /* set MAC hardware address */
+    memcpy(netif->hwaddr, ethernetifConfig->macAddress, NETIF_MAX_HWADDR_LEN);
+
+    /* maximum transfer unit */
+    netif->mtu = 1500; /* TODO: define a config */
+
+    /* device capabilities */
+    /* don't set NETIF_FLAG_ETHARP if this device is not an ethernet one */
+    netif->flags |= NETIF_FLAG_BROADCAST | NETIF_FLAG_ETHARP | NETIF_FLAG_LINK_UP;
+
+    /* ENET driver initialization.*/
+    ethernetif_enet_init(netif, ethernetif, ethernetifConfig);
+
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+    /*
+     * For hardware/netifs that implement MAC filtering.
+     * All-nodes link-local is handled by default, so we must let the hardware know
+     * to allow multicast packets in.
+     * Should set mld_mac_filter previously. */
+    if (netif->mld_mac_filter != NULL)
+    {
+        ip6_addr_t ip6_allnodes_ll;
+        ip6_addr_set_allnodes_linklocal(&ip6_allnodes_ll);
+        netif->mld_mac_filter(netif, &ip6_allnodes_ll, NETIF_ADD_MAC_FILTER);
+    }
+#endif /* LWIP_IPV6 && LWIP_IPV6_MLD */
+
+    return ERR_OK;
+}
diff --git a/port/enet_ethernetif.h b/port/enet_ethernetif.h
new file mode 100644
index 00000000..eb548ca0
--- /dev/null
+++ b/port/enet_ethernetif.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+/*
+ * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
+ * Copyright 2016-2021, 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef ENET_ETHERNETIF_H
+#define ENET_ETHERNETIF_H
+
+#include "lwip/err.h"
+#include "lwip/netif.h"
+#include "lwip/timeouts.h"
+#include "netif/ethernet.h"
+#include "fsl_phy.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "fsl_debug_console.h"
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+
+#define ENET_TIMEOUT        (0xFFFU)
+
+/* ENET IRQ priority. Used in FreeRTOS. */
+/* Interrupt priorities. */
+#ifdef __CA7_REV
+#ifndef ENET_PRIORITY
+    #define ENET_PRIORITY       (21U)
+#endif
+#ifndef ENET_1588_PRIORITY
+    #define ENET_1588_PRIORITY  (20U)
+#endif
+#else
+#ifndef ENET_PRIORITY
+    #define ENET_PRIORITY       (6U)
+#endif
+#ifndef ENET_1588_PRIORITY
+    #define ENET_1588_PRIORITY  (5U)
+#endif
+#endif
+
+/*  Defines Ethernet Autonegotiation Timeout during initialization.
+ *  Set it to 0 to disable the waiting. */
+#ifndef ENET_ATONEGOTIATION_TIMEOUT
+    #define ENET_ATONEGOTIATION_TIMEOUT     (0x2FFFFU)
+#endif
+
+/* Define those to better describe your network interface. */
+#define IFNAME0 'e'
+#define IFNAME1 'n'
+
+#define ENET_RING_NUM 1U
+
+/**
+ * Helper struct to hold data for configuration of ethernet interface.
+ */
+typedef struct ethernetif_config
+{
+    phy_handle_t *phyHandle;
+    uint8_t macAddress[NETIF_MAX_HWADDR_LEN];
+} ethernetif_config_t;
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+/**
+ * This function should be passed as a parameter to netif_add()
+ * if you initialize the first ENET interface.
+ */
+err_t ethernetif0_init(struct netif *netif);
+
+#if (defined(FSL_FEATURE_SOC_ENET_COUNT) && (FSL_FEATURE_SOC_ENET_COUNT > 1)) \
+ || (defined(FSL_FEATURE_SOC_LPC_ENET_COUNT) && (FSL_FEATURE_SOC_LPC_ENET_COUNT > 1))
+/**
+ * This function should be passed as a parameter to netif_add()
+ * if you initialize the second ENET interface.
+ */
+err_t ethernetif1_init(struct netif *netif);
+#endif /* FSL_FEATURE_SOC_*_ENET_COUNT */
+
+/**
+ * This function should be called when a packet is ready to be read
+ * from the interface.
+ * It is used by bare-metal applications.
+ *
+ * @param netif the lwip network interface structure for this ethernetif
+ */
+void ethernetif_input( struct netif *netif);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif /* ENET_ETHERNETIF_H */
diff --git a/port/enet_ethernetif_imx.c b/port/enet_ethernetif_imx.c
new file mode 100644
index 00000000..aa2fa97a
--- /dev/null
+++ b/port/enet_ethernetif_imx.c
@@ -0,0 +1,759 @@
+/*
+ * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+/*
+ * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
+ * Copyright 2016-2021, 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include "lwip/opt.h"
+#include "lwip/def.h"
+#include "lwip/ethip6.h"
+#include "lwip/igmp.h"
+#include "lwip/mem.h"
+#include "lwip/mld6.h"
+#include "lwip/pbuf.h"
+#include "lwip/snmp.h"
+#include "lwip/stats.h"
+#include "lwip/sys.h"
+#include "netif/etharp.h"
+#include "netif/ppp/pppoe.h"
+
+#if USE_RTOS && defined(SDK_OS_FREE_RTOS)
+#include "FreeRTOS.h"
+#include "event_groups.h"
+#endif
+
+#include "enet_ethernetif.h"
+#include "enet_ethernetif_priv.h"
+
+#include "fsl_enet.h"
+#include "fsl_phy.h"
+
+/*
+ * Padding of ethernet frames has to be disabled for zero-copy functionality
+ * since ENET driver requires the starting buffer addresses to be aligned.
+ */
+#if ETH_PAD_SIZE != 0
+#error "ETH_PAD_SIZE != 0"
+#endif /* ETH_PAD_SIZE != 0 */
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+
+/* The length of RX buffer. */
+#ifndef ENET_RXBUFF_SIZE
+#define ENET_RXBUFF_SIZE (ENET_FRAME_MAX_FRAMELEN)
+#endif
+
+/* The number of ENET buffers needed to receive frame of maximum length. */
+#define MAX_BUFFERS_PER_FRAME \
+    ((ENET_FRAME_MAX_FRAMELEN / ENET_RXBUFF_SIZE) + ((ENET_FRAME_MAX_FRAMELEN % ENET_RXBUFF_SIZE == 0) ? 0 : 1))
+
+/* The length of TX buffer. */
+#ifndef ENET_TXBUFF_SIZE
+#define ENET_TXBUFF_SIZE (ENET_FRAME_MAX_FRAMELEN)
+#endif
+
+/* The number of buffer descriptors in ENET RX ring. */
+#ifndef ENET_RXBD_NUM
+#define ENET_RXBD_NUM (5)
+#endif
+
+/* Ring should be able to receive at least 1 frame with maximum length. */
+#if ENET_RXBD_NUM < MAX_BUFFERS_PER_FRAME
+#error "ENET_RXBD_NUM < MAX_BUFFERS_PER_FRAME"
+#endif
+
+/* The number of RX buffers. ENET_RXBD_NUM is always held by ENET driver,
+ * so a couple more are needed to pass zero-copy data into lwIP. */
+#ifndef ENET_RXBUFF_NUM
+#define ENET_RXBUFF_NUM (ENET_RXBD_NUM * 2)
+#endif
+
+/* At least ENET_RXBD_NUM number of buffers is always held by ENET driver for RX.
+ * Some additional buffers are needed to pass at least one frame zero-copy data to lwIP. */
+#if ENET_RXBUFF_NUM < (ENET_RXBD_NUM + MAX_BUFFERS_PER_FRAME)
+#error "ENET_RXBUFF_NUM < (ENET_RXBD_NUM + MAX_BUFFERS_PER_FRAME)"
+#endif
+
+/* The number of buffer descriptors in ENET TX ring. */
+#ifndef ENET_TXBD_NUM
+#define ENET_TXBD_NUM (5)
+#endif
+
+#if defined(FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL) && FSL_SDK_ENABLE_DRIVER_CACHE_CONTROL
+#if defined(FSL_FEATURE_L2CACHE_LINESIZE_BYTE) && \
+    ((!defined(FSL_SDK_DISBLE_L2CACHE_PRESENT)) || (FSL_SDK_DISBLE_L2CACHE_PRESENT == 0))
+#if defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
+#define FSL_CACHE_LINESIZE_MAX  MAX(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE, FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
+#define FSL_ENET_BUFF_ALIGNMENT MAX(ENET_BUFF_ALIGNMENT, FSL_CACHE_LINESIZE_MAX)
+#else
+#define FSL_ENET_BUFF_ALIGNMENT MAX(ENET_BUFF_ALIGNMENT, FSL_FEATURE_L2CACHE_LINESIZE_BYTE)
+#endif
+#elif defined(FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
+#define FSL_ENET_BUFF_ALIGNMENT MAX(ENET_BUFF_ALIGNMENT, FSL_FEATURE_L1DCACHE_LINESIZE_BYTE)
+#else
+#define FSL_ENET_BUFF_ALIGNMENT ENET_BUFF_ALIGNMENT
+#endif
+#else
+#define FSL_ENET_BUFF_ALIGNMENT ENET_BUFF_ALIGNMENT
+#endif
+
+typedef uint8_t rx_buffer_t[SDK_SIZEALIGN(ENET_RXBUFF_SIZE, FSL_ENET_BUFF_ALIGNMENT)];
+typedef uint8_t tx_buffer_t[SDK_SIZEALIGN(ENET_TXBUFF_SIZE, FSL_ENET_BUFF_ALIGNMENT)];
+
+/*!
+ * @brief Used to wrap received data in a pbuf to be passed into lwIP
+ *        without copying.
+ * Once last reference is released, buffer can be used by ENET RX DMA again.
+ */
+typedef struct rx_pbuf_wrapper
+{
+    struct pbuf_custom p;      /*!< Pbuf wrapper. Has to be first. */
+    void *buffer;              /*!< Original buffer wrapped by p. */
+    volatile bool buffer_used; /*!< Wrapped buffer is used by ENET or lwIP. */
+    struct netif *netif;       /*!< Network interface context data. */
+} rx_pbuf_wrapper_t;
+
+/**
+ * Helper struct to hold private data used to operate your ethernet interface.
+ */
+struct ethernetif
+{
+    ENET_Type *base;
+#if (defined(FSL_FEATURE_SOC_ENET_COUNT) && (FSL_FEATURE_SOC_ENET_COUNT > 0)) || \
+    (USE_RTOS && defined(SDK_OS_FREE_RTOS))
+    enet_handle_t handle;
+#endif
+#if USE_RTOS && defined(SDK_OS_FREE_RTOS)
+    EventGroupHandle_t enetTransmitAccessEvent;
+    EventBits_t txFlag;
+#endif
+    enet_rx_bd_struct_t *RxBuffDescrip;
+    enet_tx_bd_struct_t *TxBuffDescrip;
+    rx_buffer_t *RxDataBuff;
+    tx_buffer_t *TxDataBuff;
+    rx_pbuf_wrapper_t RxPbufs[ENET_RXBUFF_NUM];
+};
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+static void ethernetif_rx_release(struct pbuf *p);
+
+/*******************************************************************************
+ * Code
+ ******************************************************************************/
+#if USE_RTOS && defined(SDK_OS_FREE_RTOS)
+static void ethernet_callback(ENET_Type *base,
+                              enet_handle_t *handle,
+#if FSL_FEATURE_ENET_QUEUE > 1
+                              uint32_t ringId,
+#endif /* FSL_FEATURE_ENET_QUEUE */
+                              enet_event_t event,
+                              enet_frame_info_t *frameInfo,
+                              void *userData)
+{
+    struct netif *netif           = (struct netif *)userData;
+    struct ethernetif *ethernetif = netif->state;
+    BaseType_t xResult;
+
+    switch (event)
+    {
+        case kENET_RxEvent:
+            /* Disabling RX interrupts required by ENET_GetRxFrame() when called from ISR */
+            ENET_DisableInterrupts(ethernetif->base, (uint32_t)kENET_RxFrameInterrupt);
+            ethernetif_input(netif);
+            ENET_EnableInterrupts(ethernetif->base, (uint32_t)kENET_RxFrameInterrupt);
+            break;
+        case kENET_TxEvent:
+        {
+            portBASE_TYPE taskToWake = pdFALSE;
+
+#ifdef __CA7_REV
+            if (SystemGetIRQNestingLevel())
+#else
+            if (__get_IPSR())
+#endif
+            {
+                xResult =
+                    xEventGroupSetBitsFromISR(ethernetif->enetTransmitAccessEvent, ethernetif->txFlag, &taskToWake);
+                if ((pdPASS == xResult) && (pdTRUE == taskToWake))
+                {
+                    portYIELD_FROM_ISR(taskToWake);
+                }
+            }
+            else
+            {
+                xEventGroupSetBits(ethernetif->enetTransmitAccessEvent, ethernetif->txFlag);
+            }
+        }
+        break;
+        default:
+            break;
+    }
+}
+#endif
+
+#if LWIP_IPV4 && LWIP_IGMP
+err_t ethernetif_igmp_mac_filter(struct netif *netif, const ip4_addr_t *group, enum netif_mac_filter_action action)
+{
+    struct ethernetif *ethernetif = netif->state;
+    uint8_t multicastMacAddr[6];
+    err_t result;
+
+    multicastMacAddr[0] = 0x01U;
+    multicastMacAddr[1] = 0x00U;
+    multicastMacAddr[2] = 0x5EU;
+    multicastMacAddr[3] = (group->addr >> 8) & 0x7FU;
+    multicastMacAddr[4] = (group->addr >> 16) & 0xFFU;
+    multicastMacAddr[5] = (group->addr >> 24) & 0xFFU;
+
+    switch (action)
+    {
+        case IGMP_ADD_MAC_FILTER:
+            /* Adds the ENET device to a multicast group.*/
+            ENET_AddMulticastGroup(ethernetif->base, multicastMacAddr);
+            result = ERR_OK;
+            break;
+        case IGMP_DEL_MAC_FILTER:
+            /*
+             * Moves the ENET device from a multicast group.
+             * Since the ENET_LeaveMulticastGroup() could filter out also other
+             * group addresses having the same hash, the call is commented out.
+             */
+            /* ENET_LeaveMulticastGroup(ethernetif->base, multicastMacAddr); */
+            result = ERR_OK;
+            break;
+        default:
+            result = ERR_IF;
+            break;
+    }
+
+    return result;
+}
+#endif
+
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+err_t ethernetif_mld_mac_filter(struct netif *netif, const ip6_addr_t *group, enum netif_mac_filter_action action)
+{
+    struct ethernetif *ethernetif = netif->state;
+    uint8_t multicastMacAddr[6];
+    err_t result;
+    multicastMacAddr[0] = 0x33U;
+    multicastMacAddr[1] = 0x33U;
+    multicastMacAddr[2] = (group->addr[3]) & 0xFFU;
+    multicastMacAddr[3] = (group->addr[3] >> 8) & 0xFFU;
+    multicastMacAddr[4] = (group->addr[3] >> 16) & 0xFFU;
+    multicastMacAddr[5] = (group->addr[3] >> 24) & 0xFFU;
+    switch (action)
+    {
+        case NETIF_ADD_MAC_FILTER:
+            /* Adds the ENET device to a multicast group.*/
+            ENET_AddMulticastGroup(ethernetif->base, multicastMacAddr);
+            result = ERR_OK;
+            break;
+        case NETIF_DEL_MAC_FILTER:
+            /*
+             * Moves the ENET device from a multicast group.
+             * Since the ENET_LeaveMulticastGroup() could filter out also other
+             * group addresses having the same hash, the call is commented out.
+             */
+            /* ENET_LeaveMulticastGroup(ethernetif->base, multicastMacAddr); */
+            result = ERR_OK;
+            break;
+        default:
+            result = ERR_IF;
+            break;
+    }
+    return result;
+}
+#endif
+
+/*! @brief Defines the ENET Rx memeory buffer free function pointer. */
+static void *ethernetif_rx_alloc(ENET_Type *base, void *userData, uint8_t ringId)
+{
+    struct netif *netif           = (struct netif *)userData;
+    struct ethernetif *ethernetif = netif->state;
+    void *buffer                  = NULL;
+    int i;
+
+    SYS_ARCH_DECL_PROTECT(old_level);
+    SYS_ARCH_PROTECT(old_level);
+
+    for (i = 0; i < ENET_RXBUFF_NUM; i++)
+    {
+        if (!ethernetif->RxPbufs[i].buffer_used)
+        {
+            ethernetif->RxPbufs[i].buffer_used = true;
+            buffer                             = &ethernetif->RxDataBuff[i];
+            break;
+        }
+    }
+
+    SYS_ARCH_UNPROTECT(old_level);
+
+    return buffer;
+}
+
+/**
+ * Callback for release of RX zero-copy buffer from ENET driver.
+ */
+static void ethernetif_rx_free(ENET_Type *base, void *buffer, void *userData, uint8_t ringId)
+{
+    struct netif *netif           = (struct netif *)userData;
+    struct ethernetif *ethernetif = netif->state;
+    int idx                       = ((rx_buffer_t *)buffer) - ethernetif->RxDataBuff;
+    LWIP_ASSERT("Freed buffer out of range", ((idx >= 0) && (idx < ENET_RXBUFF_NUM)));
+
+    SYS_ARCH_DECL_PROTECT(old_level);
+    SYS_ARCH_PROTECT(old_level);
+
+    LWIP_ASSERT("ethernetif_rx_free: freeing unallocated buffer", ethernetif->RxPbufs[idx].buffer_used);
+    ethernetif->RxPbufs[idx].buffer_used = false;
+
+    SYS_ARCH_UNPROTECT(old_level);
+}
+
+/**
+ * Initializes ENET driver.
+ */
+void ethernetif_enet_init(struct netif *netif,
+                          struct ethernetif *ethernetif,
+                          const ethernetif_config_t *ethernetifConfig)
+{
+    enet_config_t config;
+    uint32_t sysClock;
+    enet_buffer_config_t buffCfg[ENET_RING_NUM];
+    phy_speed_t speed;
+    phy_duplex_t duplex;
+    int i;
+
+    /* prepare the buffer configuration. */
+    buffCfg[0].rxBdNumber      = ENET_RXBD_NUM;       /* Receive buffer descriptor number. */
+    buffCfg[0].txBdNumber      = ENET_TXBD_NUM;       /* Transmit buffer descriptor number. */
+    buffCfg[0].rxBuffSizeAlign = SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT);
+    buffCfg[0].txBuffSizeAlign = SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT);
+    buffCfg[0].rxBdStartAddrAlign =
+        &(ethernetif->RxBuffDescrip[0]); /* Aligned receive buffer descriptor start address. */
+    buffCfg[0].txBdStartAddrAlign =
+        &(ethernetif->TxBuffDescrip[0]); /* Aligned transmit buffer descriptor start address. */
+    buffCfg[0].rxBufferAlign =
+        NULL; /* Receive data buffer start address. NULL when buffers are allocated by callback for RX zero-copy. */
+    buffCfg[0].txBufferAlign = &(ethernetif->TxDataBuff[0][0]); /* Transmit data buffer start address. */
+    buffCfg[0].txFrameInfo = NULL; /* Transmit frame information start address. Set only if using zero-copy transmit. */
+    buffCfg[0].rxMaintainEnable = true; /* Receive buffer cache maintain. */
+    buffCfg[0].txMaintainEnable = true; /* Transmit buffer cache maintain. */
+
+    sysClock = ethernetifConfig->phyHandle->mdioHandle->resource.csrClock_Hz;
+
+    ENET_GetDefaultConfig(&config);
+    config.ringNum     = ENET_RING_NUM;
+    config.rxBuffAlloc = ethernetif_rx_alloc;
+    config.rxBuffFree  = ethernetif_rx_free;
+    config.userData    = netif;
+#ifdef LWIP_ENET_FLEXIBLE_CONFIGURATION
+    extern void BOARD_ENETFlexibleConfigure(enet_config_t * config);
+    BOARD_ENETFlexibleConfigure(&config);
+#endif
+
+    ethernetif_phy_init(ethernetif, ethernetifConfig, &speed, &duplex);
+    config.miiSpeed  = (enet_mii_speed_t)speed;
+    config.miiDuplex = (enet_mii_duplex_t)duplex;
+
+#if USE_RTOS && defined(SDK_OS_FREE_RTOS)
+    uint32_t instance;
+    static ENET_Type *const enetBases[]  = ENET_BASE_PTRS;
+    static const IRQn_Type enetTxIrqId[] = ENET_Transmit_IRQS;
+    /*! @brief Pointers to enet receive IRQ number for each instance. */
+    static const IRQn_Type enetRxIrqId[] = ENET_Receive_IRQS;
+#if defined(ENET_ENHANCEDBUFFERDESCRIPTOR_MODE) && ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
+    /*! @brief Pointers to enet timestamp IRQ number for each instance. */
+    static const IRQn_Type enetTsIrqId[] = ENET_1588_Timer_IRQS;
+#endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
+
+    /* Create the Event for transmit busy release trigger. */
+    ethernetif->enetTransmitAccessEvent = xEventGroupCreate();
+    ethernetif->txFlag                  = 0x1;
+
+    config.interrupt |=
+        kENET_RxFrameInterrupt | kENET_TxFrameInterrupt | kENET_TxBufferInterrupt | kENET_LateCollisionInterrupt;
+    config.callback = ethernet_callback;
+
+    config.macSpecialConfig = kENET_ControlPromiscuousEnable;
+
+    for (instance = 0; instance < ARRAY_SIZE(enetBases); instance++)
+    {
+        if (enetBases[instance] == ethernetif->base)
+        {
+#ifdef __CA7_REV
+            GIC_SetPriority(enetRxIrqId[instance], ENET_PRIORITY);
+            GIC_SetPriority(enetTxIrqId[instance], ENET_PRIORITY);
+#if defined(ENET_ENHANCEDBUFFERDESCRIPTOR_MODE) && ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
+            GIC_SetPriority(enetTsIrqId[instance], ENET_1588_PRIORITY);
+#endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
+#else
+            NVIC_SetPriority(enetRxIrqId[instance], ENET_PRIORITY);
+            NVIC_SetPriority(enetTxIrqId[instance], ENET_PRIORITY);
+#if defined(ENET_ENHANCEDBUFFERDESCRIPTOR_MODE) && ENET_ENHANCEDBUFFERDESCRIPTOR_MODE
+            NVIC_SetPriority(enetTsIrqId[instance], ENET_1588_PRIORITY);
+#endif /* ENET_ENHANCEDBUFFERDESCRIPTOR_MODE */
+#endif /* __CA7_REV */
+            break;
+        }
+    }
+
+    LWIP_ASSERT("Input Ethernet base error!", (instance != ARRAY_SIZE(enetBases)));
+#endif /* USE_RTOS */
+
+    for (i = 0; i < ENET_RXBUFF_NUM; i++)
+    {
+        ethernetif->RxPbufs[i].p.custom_free_function = ethernetif_rx_release;
+        ethernetif->RxPbufs[i].buffer                 = &(ethernetif->RxDataBuff[i][0]);
+        ethernetif->RxPbufs[i].buffer_used            = false;
+        ethernetif->RxPbufs[i].netif                  = netif;
+    }
+
+    /* Initialize the ENET module. */
+    ENET_Init(ethernetif->base, &ethernetif->handle, &config, &buffCfg[0], netif->hwaddr, sysClock);
+
+    ENET_ActiveRead(ethernetif->base);
+}
+
+void **ethernetif_enet_ptr(struct ethernetif *ethernetif)
+{
+    return (void **)&(ethernetif->base);
+}
+
+/**
+ * Returns next buffer for TX.
+ * Can wait if no buffer available.
+ */
+static unsigned char *enet_get_tx_buffer(struct ethernetif *ethernetif)
+{
+    static unsigned char ucBuffer[ENET_FRAME_MAX_FRAMELEN];
+    return ucBuffer;
+}
+
+/**
+ * Sends frame via ENET.
+ */
+static err_t enet_send_frame(struct ethernetif *ethernetif, unsigned char *data, const uint32_t length)
+{
+#if USE_RTOS && defined(SDK_OS_FREE_RTOS)
+    {
+        status_t result;
+
+        do
+        {
+            result = ENET_SendFrame(ethernetif->base, &ethernetif->handle, data, length, 0, false, NULL);
+
+            if (result == kStatus_ENET_TxFrameBusy)
+            {
+                xEventGroupWaitBits(ethernetif->enetTransmitAccessEvent, ethernetif->txFlag, pdTRUE, (BaseType_t) false,
+                                    portMAX_DELAY);
+            }
+
+        } while (result == kStatus_ENET_TxFrameBusy);
+        return ERR_OK;
+    }
+#else
+    {
+        uint32_t counter;
+
+        for (counter = ENET_TIMEOUT; counter != 0U; counter--)
+        {
+            if (ENET_SendFrame(ethernetif->base, &ethernetif->handle, data, length, 0, false, NULL) !=
+                kStatus_ENET_TxFrameBusy)
+            {
+                return ERR_OK;
+            }
+        }
+
+        return ERR_TIMEOUT;
+    }
+#endif
+}
+
+/**
+ * Reclaims RX buffer held by the p after p is no longer used
+ * by the application / lwIP.
+ */
+static void ethernetif_rx_release(struct pbuf *p)
+{
+    rx_pbuf_wrapper_t *wrapper    = (rx_pbuf_wrapper_t *)p;
+    struct netif *netif           = wrapper->netif;
+    struct ethernetif *ethernetif = netif->state;
+
+    ethernetif_rx_free(ethernetif->base, wrapper->buffer, netif, 0);
+}
+
+/** Wraps received buffer(s) into a pbuf or a pbuf chain and returns it. */
+static struct pbuf *ethernetif_rx_frame_to_pbufs(struct netif *netif, struct ethernetif *ethernetif, enet_rx_frame_struct_t *rxFrame)
+{
+    void *buffer;
+    uint16_t bufferLength;
+    rx_pbuf_wrapper_t *wrapper;
+    uint16_t len   = 0U;
+    struct pbuf *p = NULL;
+    struct pbuf *q = NULL;
+    int idx;
+    int i;
+
+    for (i = 0; ((i < MAX_BUFFERS_PER_FRAME) && (len < rxFrame->totLen)); i++)
+    {
+        buffer       = rxFrame->rxBuffArray[i].buffer;
+        bufferLength = rxFrame->rxBuffArray[i].length;
+        len += bufferLength;
+
+        /* Find pbuf wrapper for the actually read byte buffer */
+        idx = ((rx_buffer_t *)buffer) - ethernetif->RxDataBuff;
+        LWIP_ASSERT("Buffer returned by ENET_GetRxFrame() doesn't match any RX buffer descriptor",
+                    ((idx >= 0) && (idx < ENET_RXBUFF_NUM)));
+        wrapper = &ethernetif->RxPbufs[idx];
+        LWIP_ASSERT("Buffer returned by ENET_GetRxFrame() doesn't match wrapper buffer", wrapper->buffer == buffer);
+
+        /* Wrap the received buffer in pbuf. */
+        if (p == NULL)
+        {
+            p = pbuf_alloced_custom(PBUF_RAW, bufferLength, PBUF_REF, &wrapper->p, buffer, bufferLength);
+            LWIP_ASSERT("pbuf_alloced_custom() failed", p);
+        }
+        else
+        {
+            q = pbuf_alloced_custom(PBUF_RAW, bufferLength, PBUF_REF, &wrapper->p, buffer, bufferLength);
+            LWIP_ASSERT("pbuf_alloced_custom() failed", q);
+
+            pbuf_cat(p, q);
+        }
+    }
+
+    LWIP_ASSERT("p->tot_len != rxFrame->totLen", p->tot_len == rxFrame->totLen);
+
+    MIB2_STATS_NETIF_ADD(netif, ifinoctets, p->tot_len);
+    if (((u8_t *)p->payload)[0] & 1)
+    {
+        /* broadcast or multicast packet */
+        MIB2_STATS_NETIF_INC(netif, ifinnucastpkts);
+    }
+    else
+    {
+        /* unicast packet */
+        MIB2_STATS_NETIF_INC(netif, ifinucastpkts);
+    }
+
+    LINK_STATS_INC(link.recv);
+
+    return p;
+}
+
+struct pbuf *ethernetif_linkinput(struct netif *netif)
+{
+    struct ethernetif *ethernetif = netif->state;
+    enet_buffer_struct_t buffers[MAX_BUFFERS_PER_FRAME];
+    enet_rx_frame_struct_t rxFrame = {.rxBuffArray = &buffers[0]};
+    struct pbuf *p                 = NULL;
+    status_t status;
+
+    /* Read frame. */
+    status = ENET_GetRxFrame(ethernetif->base, &ethernetif->handle, &rxFrame, 0);
+
+    switch (status)
+    {
+        case kStatus_Success:
+            /* Frame read, process it into pbufs. */
+            p = ethernetif_rx_frame_to_pbufs(netif, ethernetif, &rxFrame);
+            break;
+
+        case kStatus_ENET_RxFrameEmpty:
+            /* Frame not available. */
+            break;
+
+        case kStatus_ENET_RxFrameError:
+            /* Error receiving frame */
+            LWIP_DEBUGF(NETIF_DEBUG, ("ethernetif_linkinput: RxFrameError\n"));
+            LINK_STATS_INC(link.drop);
+            MIB2_STATS_NETIF_INC(netif, ifindiscards);
+            break;
+
+        case kStatus_ENET_RxFrameDrop:
+            /* Frame received, but it had to be dropped
+             * because new buffer(s) allocation failed in the ENET driver. */
+            LINK_STATS_INC(link.drop);
+            MIB2_STATS_NETIF_INC(netif, ifindiscards);
+            break;
+
+        default:
+            LWIP_ASSERT("Unhandled return value.", 0);
+            break;
+    }
+
+    return p;
+}
+
+err_t ethernetif_linkoutput(struct netif *netif, struct pbuf *p)
+{
+    err_t result;
+    struct ethernetif *ethernetif = netif->state;
+    struct pbuf *q;
+    unsigned char *pucBuffer;
+    unsigned char *pucChar;
+
+    LWIP_ASSERT("Output packet buffer empty", p);
+
+    pucBuffer = enet_get_tx_buffer(ethernetif);
+    if (pucBuffer == NULL)
+    {
+        return ERR_BUF;
+    }
+
+    /* Initiate transfer. */
+
+#if ETH_PAD_SIZE
+    pbuf_header(p, -ETH_PAD_SIZE); /* drop the padding word */
+#endif
+
+    if (p->len == p->tot_len)
+    {
+        /* No pbuf chain, don't have to copy -> faster. */
+        pucBuffer = (unsigned char *)p->payload;
+    }
+    else
+    {
+        /* pbuf chain, copy into contiguous ucBuffer. */
+        if (p->tot_len > ENET_FRAME_MAX_FRAMELEN)
+        {
+            return ERR_BUF;
+        }
+        else
+        {
+            pucChar = pucBuffer;
+
+            for (q = p; q != NULL; q = q->next)
+            {
+                /* Send the data from the pbuf to the interface, one pbuf at a
+                time. The size of the data in each pbuf is kept in the ->len
+                variable. */
+                /* send data from(q->payload, q->len); */
+                memcpy(pucChar, q->payload, q->len);
+                pucChar += q->len;
+            }
+        }
+    }
+
+    /* Send frame. */
+    result = enet_send_frame(ethernetif, pucBuffer, p->tot_len);
+
+    MIB2_STATS_NETIF_ADD(netif, ifoutoctets, p->tot_len);
+    if (((u8_t *)p->payload)[0] & 1)
+    {
+        /* broadcast or multicast packet*/
+        MIB2_STATS_NETIF_INC(netif, ifoutnucastpkts);
+    }
+    else
+    {
+        /* unicast packet */
+        MIB2_STATS_NETIF_INC(netif, ifoutucastpkts);
+    }
+    /* increase ifoutdiscards or ifouterrors on error */
+
+#if ETH_PAD_SIZE
+    pbuf_header(p, ETH_PAD_SIZE); /* reclaim the padding word */
+#endif
+
+    LINK_STATS_INC(link.xmit);
+
+    return result;
+}
+
+/**
+ * Should be called at the beginning of the program to set up the
+ * first network interface. It calls the function ethernetif_init() to do the
+ * actual setup of the hardware.
+ *
+ * This function should be passed as a parameter to netif_add().
+ *
+ * @param netif the lwip network interface structure for this ethernetif
+ * @return ERR_OK if the loopif is initialized
+ *         ERR_MEM if private data couldn't be allocated
+ *         any other err_t on error
+ */
+err_t ethernetif0_init(struct netif *netif)
+{
+    static struct ethernetif ethernetif_0;
+
+    AT_NONCACHEABLE_SECTION_ALIGN(static enet_rx_bd_struct_t rxBuffDescrip_0[ENET_RXBD_NUM], FSL_ENET_BUFF_ALIGNMENT);
+    AT_NONCACHEABLE_SECTION_ALIGN(static enet_tx_bd_struct_t txBuffDescrip_0[ENET_TXBD_NUM], FSL_ENET_BUFF_ALIGNMENT);
+
+    AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t rxDataBuff_0[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, FSL_ENET_BUFF_ALIGNMENT)],FSL_ENET_BUFF_ALIGNMENT);
+    AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t txDataBuff_0[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, FSL_ENET_BUFF_ALIGNMENT)],FSL_ENET_BUFF_ALIGNMENT);
+
+    ethernetif_0.RxBuffDescrip = &(rxBuffDescrip_0[0]);
+    ethernetif_0.TxBuffDescrip = &(txBuffDescrip_0[0]);
+    ethernetif_0.RxDataBuff    = &(rxDataBuff_0[0]);
+    ethernetif_0.TxDataBuff    = &(txDataBuff_0[0]);
+
+    return ethernetif_init(netif, &ethernetif_0, ethernetif_get_enet_base(0U), (ethernetif_config_t *)netif->state);
+}
+
+#if defined(FSL_FEATURE_SOC_ENET_COUNT) && (FSL_FEATURE_SOC_ENET_COUNT > 1)
+/**
+ * Should be called at the beginning of the program to set up the
+ * second network interface. It calls the function ethernetif_init() to do the
+ * actual setup of the hardware.
+ *
+ * This function should be passed as a parameter to netif_add().
+ *
+ * @param netif the lwip network interface structure for this ethernetif
+ * @return ERR_OK if the loopif is initialized
+ *         ERR_MEM if private data couldn't be allocated
+ *         any other err_t on error
+ */
+err_t ethernetif1_init(struct netif *netif)
+{
+    static struct ethernetif ethernetif_1;
+    AT_NONCACHEABLE_SECTION_ALIGN(static enet_rx_bd_struct_t rxBuffDescrip_1[ENET_RXBD_NUM], FSL_ENET_BUFF_ALIGNMENT);
+    AT_NONCACHEABLE_SECTION_ALIGN(static enet_tx_bd_struct_t txBuffDescrip_1[ENET_TXBD_NUM], FSL_ENET_BUFF_ALIGNMENT);
+    SDK_ALIGN(static rx_buffer_t rxDataBuff_1[ENET_RXBUFF_NUM], FSL_ENET_BUFF_ALIGNMENT);
+    SDK_ALIGN(static tx_buffer_t txDataBuff_1[ENET_TXBD_NUM], FSL_ENET_BUFF_ALIGNMENT);
+    ethernetif_1.RxBuffDescrip = &(rxBuffDescrip_1[0]);
+    ethernetif_1.TxBuffDescrip = &(txBuffDescrip_1[0]);
+    ethernetif_1.RxDataBuff    = &(rxDataBuff_1[0]);
+    ethernetif_1.TxDataBuff    = &(txDataBuff_1[0]);
+    return ethernetif_init(netif, &ethernetif_1, ethernetif_get_enet_base(1U), (ethernetif_config_t *)netif->state);
+}
+#endif /* FSL_FEATURE_SOC_*_ENET_COUNT */
diff --git a/port/enet_ethernetif_priv.h b/port/enet_ethernetif_priv.h
new file mode 100644
index 00000000..7e3e644b
--- /dev/null
+++ b/port/enet_ethernetif_priv.h
@@ -0,0 +1,80 @@
+/*
+ * Copyright 2019 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef ENET_ETHERNETIF_PRIV_H
+#define ENET_ETHERNETIF_PRIV_H
+
+#include "lwip/err.h"
+
+struct ethernetif;
+
+#if defined(__cplusplus)
+extern "C" {
+#endif /* __cplusplus */
+
+err_t ethernetif_init(struct netif *netif, struct ethernetif *ethernetif,
+                      void *enetBase,
+                      const ethernetif_config_t *ethernetifConfig);
+
+void ethernetif_enet_init(struct netif *netif, struct ethernetif *ethernetif,
+                          const ethernetif_config_t *ethernetifConfig);
+
+void ethernetif_phy_init(struct ethernetif *ethernetif,
+                         const ethernetif_config_t *ethernetifConfig,
+                         phy_speed_t *speed,
+                         phy_duplex_t *duplex);
+
+void *ethernetif_get_enet_base(const uint8_t enetIdx);
+
+#if defined(FSL_FEATURE_SOC_ENET_QOS_COUNT) && (FSL_FEATURE_SOC_ENET_QOS_COUNT > 0)
+void *ethernetif_get_enet_qos_base(const uint8_t enetIdx);
+#endif
+
+void **ethernetif_enet_ptr(struct ethernetif *ethernetif);
+
+#if LWIP_IPV4 && LWIP_IGMP
+err_t ethernetif_igmp_mac_filter(struct netif *netif, const ip4_addr_t *group,
+                                 enum netif_mac_filter_action action);
+#endif
+
+#if LWIP_IPV6 && LWIP_IPV6_MLD
+err_t ethernetif_mld_mac_filter(struct netif *netif, const ip6_addr_t *group,
+                                enum netif_mac_filter_action action);
+#endif
+
+/**
+ * Should allocate a pbuf and transfer the bytes of the incoming
+ * packet from the interface into the pbuf.
+ *
+ * @param netif the lwip network interface structure for this ethernetif
+ * @return a pbuf filled with the received packet (including MAC header)
+ *         NULL on memory error
+ */
+struct pbuf *ethernetif_linkinput(struct netif *netif);
+
+/**
+ * This function should do the actual transmission of the packet. The packet is
+ * contained in the pbuf that is passed to the function. This pbuf
+ * might be chained.
+ *
+ * @param netif the lwip network interface structure for this ethernetif
+ * @param p the MAC packet to send (e.g. IP packet including MAC addresses and type)
+ * @return ERR_OK if the packet could be sent
+ *         an err_t value if the packet couldn't be sent
+ *
+ * @note Returning ERR_MEM here if a DMA queue of your MAC is full can lead to
+ *       strange results. You might consider waiting for space in the DMA queue
+ *       to become available since the stack doesn't retry to send a packet
+ *       dropped because of memory failure (except for the TCP timers).
+ */
+err_t ethernetif_linkoutput(struct netif *netif, struct pbuf *p);
+
+#if defined(__cplusplus)
+}
+#endif /* __cplusplus */
+
+#endif /* ENET_ETHERNETIF_PRIV_H */
diff --git a/port/sys_arch.c b/port/sys_arch.c
new file mode 100644
index 00000000..d6c4f8e7
--- /dev/null
+++ b/port/sys_arch.c
@@ -0,0 +1,798 @@
+/*
+ * Copyright (c) 2001-2003 Swedish Institute of Computer Science.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
+ * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
+ * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
+ * OF SUCH DAMAGE.
+ *
+ * This file is part of the lwIP TCP/IP stack.
+ *
+ * Author: Adam Dunkels <adam@sics.se>
+ *
+ */
+
+/*
+ * Copyright (c) 2013-2016, Freescale Semiconductor, Inc.
+ * Copyright 2016-2020, 2023 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+//*****************************************************************************
+//
+// Include OS functionality.
+//
+//*****************************************************************************
+
+/* ------------------------ System architecture includes ----------------------------- */
+#include "arch/sys_arch.h"
+#include "fsl_common_arm.h"
+
+/* ------------------------ lwIP includes --------------------------------- */
+
+#include "lwip/debug.h"
+#include "lwip/def.h"
+#include "lwip/sys.h"
+#include "lwip/mem.h"
+#include "lwip/stats.h"
+#include "lwip/tcpip.h"
+#if NO_SYS
+#include "lwip/init.h"
+#endif
+#include <stdio.h>
+
+#ifndef errno
+int errno = 0;
+#endif
+
+/*
+ * Prints an assertion messages and aborts execution.
+ */
+void sys_assert( char *pcMessage )
+{
+//FSL:only needed for debugging
+#ifdef LWIP_DEBUG
+    printf(pcMessage);
+    printf("\n\r");
+#endif
+#if !NO_SYS
+    portENTER_CRITICAL();
+#endif
+    for (;;)
+    {}
+}
+
+/************************************************************************
+* Generates a pseudo-random number.
+* NOTE: Contrubuted by the FNET project.
+*************************************************************************/
+static  u32_t _rand_value;
+u32_t lwip_rand(void)
+{
+    _rand_value = _rand_value * 1103515245u + 12345u;
+	return((u32_t)(_rand_value>>16u) % (32767u + 1u));
+}
+
+#if !NO_SYS
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_new
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Creates a new mailbox
+ * Inputs:
+ *      int size                -- Size of elements in the mailbox
+ * Outputs:
+ *      sys_mbox_t              -- Handle to new mailbox
+ *---------------------------------------------------------------------------*/
+err_t sys_mbox_new( sys_mbox_t *pxMailBox, int iSize )
+{
+err_t xReturn = ERR_MEM;
+    *pxMailBox = xQueueCreate( iSize, sizeof( void * ) );
+    if( *pxMailBox != NULL )
+    {
+        xReturn = ERR_OK;
+        SYS_STATS_INC_USED( mbox );
+    }
+    return xReturn;
+}
+
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_free
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Deallocates a mailbox. If there are messages still present in the
+ *      mailbox when the mailbox is deallocated, it is an indication of a
+ *      programming error in lwIP and the developer should be notified.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ * Outputs:
+ *      sys_mbox_t              -- Handle to new mailbox
+ *---------------------------------------------------------------------------*/
+void sys_mbox_free( sys_mbox_t *pxMailBox )
+{
+unsigned long ulMessagesWaiting;
+
+    ulMessagesWaiting = uxQueueMessagesWaiting( *pxMailBox );
+    configASSERT( ( ulMessagesWaiting == 0 ) );
+
+    #if SYS_STATS
+    {
+        if( ulMessagesWaiting != 0UL )
+        {
+            SYS_STATS_INC( mbox.err );
+        }
+
+        SYS_STATS_DEC( mbox.used );
+    }
+    #endif /* SYS_STATS */
+
+    vQueueDelete( *pxMailBox );
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_post
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Post the "msg" to the mailbox.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void *data              -- Pointer to data to post
+ *---------------------------------------------------------------------------*/
+void sys_mbox_post( sys_mbox_t *pxMailBox, void *pxMessageToPost )
+{
+    while( xQueueSendToBack( *pxMailBox, &pxMessageToPost, portMAX_DELAY ) != pdTRUE );
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_trypost
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Try to post the "msg" to the mailbox.  Returns immediately with
+ *      error if cannot.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void *msg               -- Pointer to data to post
+ * Outputs:
+ *      err_t                   -- ERR_OK if message posted, else ERR_MEM
+ *                                  if not.
+ *---------------------------------------------------------------------------*/
+err_t sys_mbox_trypost( sys_mbox_t *pxMailBox, void *pxMessageToPost )
+{
+    portBASE_TYPE taskToWake = pdFALSE;
+#ifdef __CA7_REV
+    if (SystemGetIRQNestingLevel())
+#else
+    if (__get_IPSR())
+#endif
+    {
+        if (pdTRUE == xQueueSendToBackFromISR(*pxMailBox, &pxMessageToPost, &taskToWake))
+        {
+            if(taskToWake == pdTRUE)
+            {
+                portYIELD_FROM_ISR(taskToWake);
+            }
+            return ERR_OK;
+        }
+        else
+        {
+            /* The queue was already full. */
+            SYS_STATS_INC( mbox.err );
+            return ERR_MEM;
+        }
+    }
+    else
+    {
+        if(pdTRUE == xQueueSendToBack(*pxMailBox, &pxMessageToPost, 0) )
+        {
+            return ERR_OK;
+        }
+        else
+        {
+            /* The queue was already full. */
+            SYS_STATS_INC( mbox.err );
+            return ERR_MEM;
+        }
+    }
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_mbox_trypost_fromisr
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Try to post the "msg" to the mailbox.  Returns immediately with
+ *      error if cannot. To be be used from ISR.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void *msg               -- Pointer to data to post
+ * Outputs:
+ *      err_t                   -- ERR_OK if message posted, else ERR_MEM
+ *                                  if not.
+ *---------------------------------------------------------------------------*/
+err_t sys_mbox_trypost_fromisr(sys_mbox_t *mbox, void *msg)
+{
+    return sys_mbox_trypost(mbox, msg);
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_mbox_fetch
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Blocks the thread until a message arrives in the mailbox, but does
+ *      not block the thread longer than "timeout" milliseconds (similar to
+ *      the sys_arch_sem_wait() function). The "msg" argument is a result
+ *      parameter that is set by the function (i.e., by doing "*msg =
+ *      ptr"). The "msg" parameter maybe NULL to indicate that the message
+ *      should be dropped.
+ *
+ *      The return values are the same as for the sys_arch_sem_wait() function:
+ *      Number of milliseconds spent waiting or SYS_ARCH_TIMEOUT if there was a
+ *      timeout.
+ *
+ *      Note that a function with a similar name, sys_mbox_fetch(), is
+ *      implemented by lwIP.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void **msg              -- Pointer to pointer to msg received
+ *      u32_t timeout           -- Number of milliseconds until timeout
+ * Outputs:
+ *      u32_t                   -- SYS_ARCH_TIMEOUT if timeout, else number
+ *                                  of milliseconds until received.
+ *---------------------------------------------------------------------------*/
+u32_t sys_arch_mbox_fetch( sys_mbox_t *pxMailBox, void **ppvBuffer, u32_t ulTimeOut )
+{
+    void *pvDummy;
+    TickType_t xStartTime, xEndTime, xElapsed;
+    unsigned long ulReturn;
+
+    xStartTime = xTaskGetTickCount();
+
+    if( NULL == ppvBuffer )
+    {
+        ppvBuffer = &pvDummy;
+    }
+
+    if( ulTimeOut != 0UL )
+    {
+        if( pdTRUE == xQueueReceive( *pxMailBox, &( *ppvBuffer ), ulTimeOut/ portTICK_PERIOD_MS ) )
+        {
+            xEndTime = xTaskGetTickCount();
+            xElapsed = ( xEndTime - xStartTime ) * portTICK_PERIOD_MS;
+
+            ulReturn = xElapsed;
+        }
+        else
+        {
+            /* Timed out. */
+            *ppvBuffer = NULL;
+            ulReturn = SYS_ARCH_TIMEOUT;
+        }
+    }
+    else
+    {
+        while( pdTRUE != xQueueReceive( *pxMailBox, &( *ppvBuffer ), portMAX_DELAY ) );
+        xEndTime = xTaskGetTickCount();
+        xElapsed = ( xEndTime - xStartTime ) * portTICK_PERIOD_MS;
+
+        if( xElapsed == 0UL )
+        {
+            xElapsed = 1UL;
+        }
+
+        ulReturn = xElapsed;
+    }
+
+    return ulReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_mbox_tryfetch
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Similar to sys_arch_mbox_fetch, but if message is not ready
+ *      immediately, we'll return with SYS_MBOX_EMPTY.  On success, 0 is
+ *      returned.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      void **msg              -- Pointer to pointer to msg received
+ * Outputs:
+ *      u32_t                   -- SYS_MBOX_EMPTY if no messages.  Otherwise,
+ *                                  return ERR_OK.
+ *---------------------------------------------------------------------------*/
+u32_t sys_arch_mbox_tryfetch( sys_mbox_t *pxMailBox, void **ppvBuffer )
+{
+void *pvDummy;
+unsigned long ulReturn;
+
+    if( ppvBuffer== NULL )
+    {
+        ppvBuffer = &pvDummy;
+    }
+
+    if( pdTRUE == xQueueReceive( *pxMailBox, &( *ppvBuffer ), 0UL ) )
+    {
+        ulReturn = ERR_OK;
+    }
+    else
+    {
+        ulReturn = SYS_MBOX_EMPTY;
+    }
+
+    return ulReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_sem_new
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Creates and returns a new semaphore. If the value of "ucCount" argument
+ *      is 0, maximum count of semaphore is 1 and the initial state is 0.
+ *      Otherwise the "ucCount" argument specifies both initial state and
+ *      maximum count of the semaphore.
+ * Inputs:
+ *      sys_mbox_t mbox         -- Handle of mailbox
+ *      u8_t ucCount            -- Initial ucCount of semaphore
+ * Outputs:
+ *      sys_sem_t               -- Created semaphore or 0 if could not create.
+ *---------------------------------------------------------------------------*/
+err_t sys_sem_new( sys_sem_t *pxSemaphore, u8_t ucCount )
+{
+err_t xReturn = ERR_MEM;
+
+    if( ucCount > 1U )
+    {
+        *pxSemaphore = xSemaphoreCreateCounting( ucCount, ucCount );
+    }
+    else
+    {
+        *pxSemaphore = xSemaphoreCreateBinary();
+    }
+
+    if( *pxSemaphore != NULL )
+    {
+        if( ucCount == 0U )
+        {
+            xSemaphoreTake( *pxSemaphore, 1UL );
+        }
+
+        xReturn = ERR_OK;
+        SYS_STATS_INC_USED( sem );
+    }
+    else
+    {
+        SYS_STATS_INC( sem.err );
+    }
+
+    return xReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_sem_wait
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Blocks the thread while waiting for the semaphore to be
+ *      signaled. If the "timeout" argument is non-zero, the thread should
+ *      only be blocked for the specified time (measured in
+ *      milliseconds).
+ *
+ *      If the timeout argument is non-zero, the return value is the number of
+ *      milliseconds spent waiting for the semaphore to be signaled. If the
+ *      semaphore wasn't signaled within the specified time, the return value is
+ *      SYS_ARCH_TIMEOUT. If the thread didn't have to wait for the semaphore
+ *      (i.e., it was already signaled), the function may return zero.
+ *
+ *      Notice that lwIP implements a function with a similar name,
+ *      sys_sem_wait(), that uses the sys_arch_sem_wait() function.
+ * Inputs:
+ *      sys_sem_t sem           -- Semaphore to wait on
+ *      u32_t timeout           -- Number of milliseconds until timeout
+ * Outputs:
+ *      u32_t                   -- Time elapsed or SYS_ARCH_TIMEOUT.
+ *---------------------------------------------------------------------------*/
+u32_t sys_arch_sem_wait( sys_sem_t *pxSemaphore, u32_t ulTimeout )
+{
+TickType_t xStartTime, xEndTime, xElapsed;
+unsigned long ulReturn;
+
+    xStartTime = xTaskGetTickCount();
+
+    if( ulTimeout != 0UL )
+    {
+        if( xSemaphoreTake( *pxSemaphore, ulTimeout / portTICK_PERIOD_MS ) == pdTRUE )
+        {
+            xEndTime = xTaskGetTickCount();
+            xElapsed = (xEndTime - xStartTime) * portTICK_PERIOD_MS;
+            ulReturn = xElapsed;
+        }
+        else
+        {
+            ulReturn = SYS_ARCH_TIMEOUT;
+        }
+    }
+    else
+    {
+        while( xSemaphoreTake( *pxSemaphore, portMAX_DELAY ) != pdTRUE );
+        xEndTime = xTaskGetTickCount();
+        xElapsed = ( xEndTime - xStartTime ) * portTICK_PERIOD_MS;
+
+        if( xElapsed == 0UL )
+        {
+            xElapsed = 1UL;
+        }
+
+        ulReturn = xElapsed;
+    }
+
+    return ulReturn;
+}
+
+/** Create a new mutex
+ * @param mutex pointer to the mutex to create
+ * @return a new mutex */
+err_t sys_mutex_new( sys_mutex_t *pxMutex )
+{
+err_t xReturn = ERR_MEM;
+
+    *pxMutex = xSemaphoreCreateMutex();
+
+    if( *pxMutex != NULL )
+    {
+        xReturn = ERR_OK;
+        SYS_STATS_INC_USED( mutex );
+    }
+    else
+    {
+        SYS_STATS_INC( mutex.err );
+    }
+
+    return xReturn;
+}
+
+/** Lock a mutex
+ * @param mutex the mutex to lock */
+void sys_mutex_lock( sys_mutex_t *pxMutex )
+{
+    while( xSemaphoreTake( *pxMutex, portMAX_DELAY ) != pdPASS );
+}
+
+/** Unlock a mutex
+ * @param mutex the mutex to unlock */
+void sys_mutex_unlock(sys_mutex_t *pxMutex )
+{
+    xSemaphoreGive( *pxMutex );
+}
+
+
+/** Delete a semaphore
+ * @param mutex the mutex to delete */
+void sys_mutex_free( sys_mutex_t *pxMutex )
+{
+    SYS_STATS_DEC( mutex.used );
+    vQueueDelete( *pxMutex );
+}
+
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_sem_signal
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Signals (releases) a semaphore
+ * Inputs:
+ *      sys_sem_t sem           -- Semaphore to signal
+ *---------------------------------------------------------------------------*/
+void sys_sem_signal( sys_sem_t *pxSemaphore )
+{
+    xSemaphoreGive( *pxSemaphore );
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_sem_free
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Deallocates a semaphore
+ * Inputs:
+ *      sys_sem_t sem           -- Semaphore to free
+ *---------------------------------------------------------------------------*/
+void sys_sem_free( sys_sem_t *pxSemaphore )
+{
+    SYS_STATS_DEC(sem.used);
+    vQueueDelete( *pxSemaphore );
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_init
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Initialize sys arch
+ *---------------------------------------------------------------------------*/
+void sys_init(void)
+{
+}
+
+u32_t sys_now(void)
+{
+    return xTaskGetTickCount() * portTICK_PERIOD_MS;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_thread_new
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      Starts a new thread with priority "iPriority" that will begin its
+ *      execution in the function "pxThread()". The "pvArg" argument will be
+ *      passed as an argument to the pxThread() function. The id of the new
+ *      thread is returned. Both the id and the priority are system
+ *      dependent.
+ * Inputs:
+ *      char *pcName            -- Name of thread
+ *      void (* pxThread)(void *pvParameters)  -- Pointer to function to run.
+ *      void *pvArg             -- Argument passed into function
+ *      int iStackSize          -- Required stack amount in words (not bytes!)
+ *      int iPriority           -- Thread priority
+ * Outputs:
+ *      sys_thread_t            -- Pointer to the new thread's structure.
+ *---------------------------------------------------------------------------*/
+sys_thread_t sys_thread_new(const char *pcName, void(*pxThread)(void *pvParameters), void *pvArg, int iStackSize, int iPriority)
+{
+    TaskHandle_t xCreatedTask;
+    portBASE_TYPE xResult;
+    sys_thread_t xReturn;
+
+    LWIP_ASSERT("invalid stacksize", iStackSize > 0);
+
+    xResult = xTaskCreate(pxThread, pcName, (configSTACK_DEPTH_TYPE)iStackSize, pvArg, iPriority, &xCreatedTask);
+    LWIP_ASSERT("task creation failed", xResult == pdPASS);
+
+    if (xResult == pdPASS)
+    {
+        xReturn = xCreatedTask;
+    }
+    else
+    {
+        xReturn = NULL;
+    }
+
+    return xReturn;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_protect
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      This optional function does a "fast" critical region protection and
+ *      returns the previous protection level. This function is only called
+ *      during very short critical regions. An embedded system which supports
+ *      ISR-based drivers might want to implement this function by disabling
+ *      interrupts. Task-based systems might want to implement this by using
+ *      a mutex or disabling tasking. This function should support recursive
+ *      calls from the same task or interrupt. In other words,
+ *      sys_arch_protect() could be called while already protected. In
+ *      that case the return value indicates that it is already protected.
+ *
+ *      sys_arch_protect() is only required if your port is supporting an
+ *      operating system.
+ * Outputs:
+ *      sys_prot_t              -- Previous protection level (not used here)
+ *---------------------------------------------------------------------------*/
+sys_prot_t sys_arch_protect( void )
+{
+    sys_prot_t result = 0;
+
+#ifdef __CA7_REV
+    if (SystemGetIRQNestingLevel())
+#else
+    if (__get_IPSR())
+#endif
+    {
+        result = portSET_INTERRUPT_MASK_FROM_ISR();
+    }
+    else
+    {
+        portENTER_CRITICAL();
+    }
+    return result;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_unprotect
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      This optional function does a "fast" set of critical region
+ *      protection to the value specified by pval. See the documentation for
+ *      sys_arch_protect() for more information. This function is only
+ *      required if your port is supporting an operating system.
+ * Inputs:
+ *      sys_prot_t              -- Previous protection level (not used here)
+ *---------------------------------------------------------------------------*/
+void sys_arch_unprotect( sys_prot_t xValue )
+{
+#ifdef __CA7_REV
+    if (SystemGetIRQNestingLevel())
+#else
+    if (__get_IPSR())
+#endif
+    {
+        portCLEAR_INTERRUPT_MASK_FROM_ISR(xValue);
+    }
+    else
+    {
+        portEXIT_CRITICAL();
+    }
+}
+
+#if LWIP_TCPIP_CORE_LOCKING
+
+static u8_t lwip_core_lock_count;
+static TaskHandle_t lwip_core_lock_holder_thread;
+
+void sys_lock_tcpip_core(void)
+{
+    sys_mutex_lock(&lock_tcpip_core);
+    if (lwip_core_lock_count == 0U)
+    {
+        lwip_core_lock_holder_thread = xTaskGetCurrentTaskHandle();
+    }
+    lwip_core_lock_count++;
+}
+
+void sys_unlock_tcpip_core(void)
+{
+    lwip_core_lock_count--;
+    if (lwip_core_lock_count == 0)
+    {
+        lwip_core_lock_holder_thread = 0;
+    }
+    sys_mutex_unlock(&lock_tcpip_core);
+}
+
+#endif /* LWIP_TCPIP_CORE_LOCKING */
+
+static TaskHandle_t lwip_tcpip_thread;
+
+void sys_mark_tcpip_thread(void)
+{
+    lwip_tcpip_thread = xTaskGetCurrentTaskHandle();
+}
+
+void sys_check_core_locking(void)
+{
+    LWIP_ASSERT("Function called from interrupt context",
+#ifdef __CA7_REV
+                (SystemGetIRQNestingLevel() == 0)
+#else
+                (__get_IPSR() == 0)
+#endif
+                );
+
+    if (lwip_tcpip_thread != 0)
+    {
+        TaskHandle_t current_thread = xTaskGetCurrentTaskHandle();
+        LWIP_UNUSED_ARG(current_thread); /* for LWIP_NOASSERT */
+
+#if LWIP_TCPIP_CORE_LOCKING
+        LWIP_UNUSED_ARG(lwip_core_lock_holder_thread); /* for LWIP_NOASSERT */
+        LWIP_ASSERT("Function called without core lock",
+                    current_thread == lwip_core_lock_holder_thread && lwip_core_lock_count > 0);
+#else /* LWIP_TCPIP_CORE_LOCKING */
+        LWIP_ASSERT("Function called from wrong thread", current_thread == lwip_tcpip_thread);
+#endif /* LWIP_TCPIP_CORE_LOCKING */
+    }
+}
+
+#else /* Bare-metal */
+
+static volatile uint32_t time_now = 0;
+
+void time_isr(void)
+{
+#ifdef __CA7_REV
+    SystemClearSystickFlag();
+#endif
+  time_now++;
+}
+
+void time_init(void)
+{
+#ifdef __CA7_REV
+    /* special for i.mx6ul */
+    SystemSetupSystick(1000U, (void *)time_isr, 0U);
+    SystemClearSystickFlag();
+#else
+    /* Set SysTick period to 1 ms and enable its interrupts */
+    extern uint32_t SystemCoreClock;
+    SysTick_Config(USEC_TO_COUNT(1000U, SystemCoreClock));
+#endif
+}
+
+
+/*
+This optional function returns the current time in milliseconds (don't care
+  for wraparound, this is only used for time diffs).
+  Not implementing this function means you cannot use some modules (e.g. TCP
+  timestamps, internal timeouts for NO_SYS==1).
+  */
+
+u32_t sys_now(void)
+{
+    return (u32_t)time_now;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_protect
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      This optional function does a "fast" critical region protection and
+ *      returns the previous protection level. This function is only called
+ *      during very short critical regions. An embedded system which supports
+ *      ISR-based drivers might want to implement this function by disabling
+ *      interrupts. Task-based systems might want to implement this by using
+ *      a mutex or disabling tasking. This function should support recursive
+ *      calls from the same task or interrupt. In other words,
+ *      sys_arch_protect() could be called while already protected. In
+ *      that case the return value indicates that it is already protected.
+ *
+ *      sys_arch_protect() is only required if your port is supporting an
+ *      operating system.
+ * Outputs:
+ *      sys_prot_t              -- Previous protection level (not used here)
+ *---------------------------------------------------------------------------*/
+sys_prot_t sys_arch_protect( void )
+{
+    sys_prot_t result;
+
+    result = (sys_prot_t)DisableGlobalIRQ();
+
+    return result;
+}
+
+/*---------------------------------------------------------------------------*
+ * Routine:  sys_arch_unprotect
+ *---------------------------------------------------------------------------*
+ * Description:
+ *      This optional function does a "fast" set of critical region
+ *      protection to the value specified by pval. See the documentation for
+ *      sys_arch_protect() for more information. This function is only
+ *      required if your port is supporting an operating system.
+ * Inputs:
+ *      sys_prot_t              -- Previous protection level (not used here)
+ *---------------------------------------------------------------------------*/
+void sys_arch_unprotect( sys_prot_t xValue )
+{
+    EnableGlobalIRQ((uint32_t)xValue);
+}
+
+void sys_check_core_locking(void)
+{
+    LWIP_ASSERT("Function called from interrupt context",
+#ifdef __CA7_REV
+                (SystemGetIRQNestingLevel() == 0)
+#else
+                (__get_IPSR() == 0)
+#endif
+                );
+}
+
+#endif /* !NO_SYS */
+
+/*-------------------------------------------------------------------------*
+ * End of File:  sys_arch.c
+ *-------------------------------------------------------------------------*/
